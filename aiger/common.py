from collections import namedtuple
from typing import NamedTuple, List

import funcy as fn
from bidict import bidict
from functools import reduce

Header = namedtuple('Header', ['max_var_index', 'num_inputs',
                               'num_latches', 'num_outputs',
                               'num_ands'])
Symbol = namedtuple('Symbol', ['kind', 'index', 'name'])
SymbolTable = namedtuple('SymbolTable', ['inputs', 'outputs', 'latches'])

class AAG(NamedTuple):
    header: Header
    inputs: List[int]
    outputs: List[int]
    latches: List[List[int]]
    gates: List[List[int]]
    symbols: SymbolTable
    comments: str

    def __rshift__(self, other):
        return seq_compose(self, other)


    def __matmul__(self, other):
        return par_compose([self, other])

    def dump(self):
        out = f"aag " + " ".join(map(str, self.header)) + '\n'
        if self.inputs:
            out += '\n'.join(map(str, self.inputs)) + '\n'
        if self.latches:
            out += '\n'.join([' '.join(map(str, xs)) for xs in self.latches]) + '\n'
        if self.outputs:
            out += '\n'.join(map(str, self.outputs)) + '\n'
        if self.gates:
            out += '\n'.join([' '.join(map(str, xs)) for xs in self.gates]) + '\n'
        if self.symbols.inputs:
            out += '\n'.join(f"i{idx} {name}" for name, idx in self.symbols.inputs.items()) + '\n'
        if self.symbols.outputs:
            out += '\n'.join(f"o{idx} {name}" for name, idx in self.symbols.outputs.items()) + '\n'
        if self.symbols.latches:
            out += '\n'.join(f"l{idx} {name}" for name, idx  in self.symbols.latches.items()) + '\n'
            out += 'c\nAutogenerated composition.\n'
        return out

    def write(self, location):
        with open(location, "w") as f:
            f.write(self.dump())

def seq_compose(aag1, aag2):
    # TODO: clean up....this is a mess...
    # TODO: Make sure latch names don't collide
    outputs1 = set(aag1.symbols.outputs.keys())
    inputs2 = set(aag2.symbols.inputs.keys())

    input2_lits = bidict({aag2.inputs[v] & -2: k
                          for k,v in aag2.symbols.inputs.items()})
    output1_lits = bidict({aag1.outputs[v] & -2: k
                           for k,v in aag1.symbols.outputs.items()})
    signed_output = {k: aag1.outputs[v]
                     for k,v in aag1.symbols.outputs.items()}
    
    n = aag1.header.max_var_index
    def update_lit(lit):
        key = lit & -2
        if key == 0:
            return lit
        negated = lit % 2

        # Check if these inputs should be wired together.
        if key in input2_lits:
            sym_name = input2_lits[key]

            if sym_name in aag1.symbols.outputs:
                new_val = aag1.outputs[aag1.symbols.outputs[sym_name]]
                return (new_val & -2) + ((new_val & 1) ^ negated)

        return lit + 2*n

    def update_lits(lits):
        return list(map(update_lit, lits))

    gates3 = aag1.gates + list(map(update_lits, aag2.gates))
    latches3 = aag1.latches + list(map(update_lits, aag2.latches))

    inputs3 = aag1.inputs + update_lits([input2_lits.inv[k]
                                         for k in inputs2 - outputs1])

    outputs3 = update_lits(aag2.outputs) + [signed_output[k]
                                            for k in outputs1 - inputs2]
    
    header1, header2 = aag1.header, aag2.header
    max_var_index = max(fn.flatten(inputs3 + outputs3 + latches3 + gates3)) >> 1
    header3 = Header(
        max_var_index,
        len(inputs3),
        len(latches3),
        len(outputs3),
        len(gates3))
    
    try:
        symbols3 = SymbolTable(
            fn.merge(aag1.symbols.inputs,
                     {n: inputs3.index(update_lit(input2_lits.inv[n])) for 
                      n in  inputs2 - outputs1}
            ),
            fn.merge(aag2.symbols.outputs,
                     {n: outputs3.index(signed_output[n]) for 
                      n in outputs1 - inputs2}
            ),
            fn.merge(aag1.symbols.latches, 
                     bidict({k: v + len(aag1.symbols.latches)
                         for k, v in aag2.symbols.latches.items()})),
        )
    except:
        import pdb; pdb.set_trace()
    # TODO: propogate comments
    return AAG(header3, inputs3, outputs3, latches3, gates3, symbols3, [''])


def lit_type(aag, lit):
    """
    Computes the kind of object the literal lit represents in aag
    """
    in_thresh = 2*(aag.header.num_inputs)+2
    in_lat_thresh = in_thresh + 2*(aag.header.num_latches)
    in_lat_and_thresh = in_lat_thresh + 2*(aag.header.num_ands)
    max_var_thresh = 2*(aag.header.max_var_index) +2
    if (lit >= 0 and lit < 2): # constant
        return "c"
    elif (lit >= 2) and (lit < in_thresh): #input
        return "i"
    elif (lit >= in_thresh) and (lit < in_lat_thresh): #latch
        return "l"
    elif (lit >= in_lat_thresh) and (lit < max_var_thresh): #and
        return "a"
    else:
        raise ValueError("Literal is too big")

def par_compose(aagcollection):
    """
    Parallel composition of a collection of aiger circuits. Inputs are shared and all other attributes are not.
    FIXME: Shared inputs are by aiger index and not by symbol name
    """

    def new_index(aag, lit, par_header, prev_gates, prev_latches):
        """
        Computes a new index for literal lit from aag.
        This new index takes into account the header of the parallel
        composition and offsets from gates and latches from other aags
        """
        lit_kind = lit_type(aag, lit)
        if lit_kind in ["c", "i"]:
            return lit
        elif lit_kind == "l":
            par_offset = 2*(par_header.num_inputs)
            aag_offset = 2*(aag.header.num_inputs)
            return lit + par_offset - aag_offset + 2*prev_latches
        elif lit_kind == "a":
            par_offset = 2*(par_header.num_inputs+par_header.num_latches)
            aag_offset = 2*(aag.header.num_inputs+aag.header.num_latches)
            return lit + par_offset - aag_offset + 2*prev_gates

    par_inputs = list(reduce(lambda x,y: x.union(y), [set(aag.inputs) for aag in aagcollection]))
    par_inputs.sort()

    num_inputs  = len(par_inputs)
    num_latches = sum([len(aag.latches) for aag in aagcollection])
    num_outputs = sum([len(aag.outputs) for aag in aagcollection])
    num_gates   = sum([len(aag.gates) for aag in aagcollection])
    max_var_index = len(par_inputs) + num_latches + num_gates

    par_header = Header(max_var_index, num_inputs, num_latches, num_outputs, num_gates)

    par_outputs = []
    par_latches = []
    par_gates = []
    # FIXME: Need to have a nontrivial symbol table. What to do with duplicate output, latch names?
    par_symbols = SymbolTable(fn.join([aag.symbols.inputs for aag in aagcollection]),
                              [],
                              [])

    prev_gates = 0
    prev_latches = 0
    for aag in aagcollection:
        # Generate index map. Uncomment to construct the index map explicitly 
        # index_kind = {i: lit_type(aag,i) for i in range(aag.header.max_var_index*2 + 2)}
        # index_map = { i: new_index(aag, i, par_header, prev_gates, prev_latches) 
        #               for i in range(aag.header.max_var_index*2+2)
        #           }

        # Bind circuit aag and prev_gates, prev_latches parameters to function 
        newi = lambda x: new_index(aag, x, par_header, prev_gates, prev_latches)

        # Add latches, gates, and outputs 
        par_latches += [[newi(i[0]), newi(i[1])] for i in aag.latches]
        par_gates += [[newi(i[0]), newi(i[1]), newi(i[2])] for i in aag.gates]
        par_outputs += [newi(i) for i in aag.outputs]

        # Increment offset from adding gates and latches 
        prev_gates += len(aag.gates)
        prev_latches += len(aag.latches)

    return AAG(par_header, par_inputs, par_outputs, par_latches, par_gates, par_symbols, [''])

