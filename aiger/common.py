from collections import namedtuple
from typing import NamedTuple, List, Tuple, Mapping
from functools import lru_cache

import funcy as fn
from bidict import bidict
from functools import reduce

Header = namedtuple('Header', ['max_var_index', 'num_inputs',
                               'num_latches', 'num_outputs',
                               'num_ands'])
Symbol = namedtuple('Symbol', ['kind', 'index', 'name'])
SymbolTable = namedtuple('SymbolTable', ['inputs', 'outputs', 'latches'])


def to_idx(lit):
    return lit >> 1


class AAG(NamedTuple):
    header: Header
    inputs: Mapping[str, int]
    outputs: Mapping[str, int]
    latches: Mapping[str, List[int]]
    gates: List[List[int]]
    comments: str

    def __rshift__(self, other):
        return seq_compose(self, other)

    def __or__(self, other):
        return par_compose(self, other)

    def dump(self):
        if self.inputs:
            input_names, input_lits = zip(*list(self.inputs.items()))

        if self.outputs:
            output_names, output_lits = zip(*list(self.outputs.items()))

        if self.latches:
            latch_names, latch_lits = zip(*list(self.latches.items()))

        str_idx = lambda lit: str(to_idx(lit))

        out = f"aag " + " ".join(map(str, self.header)) + '\n'
        if self.inputs:
            out += '\n'.join(map(str, input_lits)) + '\n'
        if self.latches:
            out += '\n'.join([' '.join(map(str, xs)) for xs in latch_lits]) + '\n'
        if self.outputs:
            out += '\n'.join(map(str, output_lits)) + '\n'
        if self.gates:
            out += '\n'.join([' '.join(map(str, xs)) for xs in self.gates]) + '\n'
        if self.inputs:
            out += '\n'.join(f"i{idx} {name}" for idx, name in enumerate(input_names)) + '\n'
        if self.outputs:
            out += '\n'.join(f"o{idx} {name}" for idx, name in enumerate(output_names)) + '\n'
        if self.latches:
            out += '\n'.join(f"l{idx} {name}" for idx, name  in enumerate(latch_names)) + '\n'

        out += 'c\nAutogenerated composition.\n'
        return out

    def write(self, location):
        with open(location, "w") as f:
            f.write(self.dump())


def seq_compose(aag1, aag2, check_precondition=True):
    output1_names = set(aag1.outputs.keys())
    input2_names = set(aag2.inputs.keys())
    interface = output1_names & input2_names

    if check_precondition:
        input1_names = set(aag1.inputs.keys())
        output2_names = set(aag2.outputs.keys())
    
        assert len((input2_names - interface) & input1_names) == 0
        assert len((output1_names - interface) & output2_names) == 0
        assert len(set(aag1.latches.keys()) & set(aag2.latches.keys())) == 0

    idx_to_name = {to_idx(lit): n for n, lit in aag2.inputs.items() 
                   if n in interface}
    n = aag1.header.max_var_index
    def new_lit(lit):
        if lit in (0, 1):
            return lit

        key = to_idx(lit)
        if key not in idx_to_name:
            return lit + 2*n

        lit2 = aag1.outputs[idx_to_name[key]]
        return (lit2 & -2) + ((lit2 & 1) ^ (lit & 1))


    def new_lits(lits):
        return fn.lmap(new_lit, lits)

    inputs3 = fn.merge(
        aag1.inputs,
        fn.walk_values(new_lit, fn.omit(aag2.inputs, interface))
    )
    outputs3 = fn.merge(
        fn.omit(aag1.outputs, interface),
        fn.walk_values(new_lit, aag2.outputs)
    )
    latches3 = fn.merge(aag1.latches, fn.walk_values(new_lits, aag2.latches))
    gates3 = aag1.gates + fn.lmap(new_lits, aag2.gates)

    lits = fn.flatten(fn.concat(inputs3.values(), outputs3.values(),
                                latches3.values(), gates3))
    header3 = Header(max(map(to_idx, lits)), len(inputs3), 
                         len(latches3), len(outputs3),
                         len(gates3))

    return AAG(header3, inputs3, outputs3, latches3, gates3, [''])


def par_compose(aag1, aag2, check_precondition=True):
    input1_names = set(aag1.inputs.keys())
    input2_names = set(aag2.inputs.keys())
    interface = input1_names & input2_names

    if check_precondition:
        assert len(set(aag1.outputs.keys()) & set(aag2.outputs.keys())) == 0
        assert len(set(aag1.latches.keys()) & set(aag2.latches.keys())) == 0

    
    idx_to_name = {to_idx(lit): n for n, lit in aag2.inputs.items() 
                   if n in interface}
    n = aag1.header.max_var_index
    def new_lit(lit):
        if lit in (0, 1):
            return lit

        key = to_idx(lit)
        if key not in idx_to_name:
            return lit + 2*n

        lit2 = aag1.inputs[idx_to_name[key]]
        return (lit2 & -2) + ((lit2 & 1) ^ (lit & 1))


    def new_lits(lits):
        return fn.lmap(new_lit, lits)

    inputs3 = fn.merge(
        aag1.inputs, 
        fn.walk_values(new_lit, fn.omit(aag2.inputs, interface)))
    outputs3 = fn.merge(aag1.outputs, fn.walk_values(new_lit, aag2.outputs))
    latches3 = fn.merge(aag1.latches, fn.walk_values(new_lits, aag2.latches))
    gates3 = aag1.gates + fn.lmap(new_lits, aag2.gates)

    lits = fn.flatten(fn.concat(inputs3.values(), outputs3.values(),
                                latches3.values(), gates3))
    header3 = Header(max(map(to_idx, lits)), len(inputs3), 
                         len(latches3), len(outputs3),
                         len(gates3))

    return AAG(header3, inputs3, outputs3, latches3, gates3, [''])
