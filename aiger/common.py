from collections import namedtuple
from typing import NamedTuple, List

import funcy as fn
from bidict import bidict

Header = namedtuple('Header', ['max_var_index', 'num_inputs',
                               'num_latches', 'num_outputs',
                               'num_ands'])
Symbol = namedtuple('Symbol', ['kind', 'index', 'name'])
SymbolTable = namedtuple('SymbolTable', ['inputs', 'outputs', 'latches'])

class AAG(NamedTuple):
    header: Header
    inputs: List[int]
    outputs: List[int]
    latches: List[List[int]]
    gates: List[List[int]]
    symbols: SymbolTable
    comments: str

    def __rshift__(self, other):
        return seq_compose(self, other)


    def __matmul__(self, other):
        raise NotImplementedError


    def dump(self):
        out = f"aag " + " ".join(map(str, self.header)) + '\n'
        if self.inputs:
            out += '\n'.join(map(str, self.inputs)) + '\n'
        if self.latches:
            out += '\n'.join([' '.join(map(str, xs)) for xs in self.latches]) + '\n'
        if self.outputs:
            out += '\n'.join(map(str, self.outputs)) + '\n'
        if self.gates:
            out += '\n'.join([' '.join(map(str, xs)) for xs in self.gates]) + '\n'
        if self.symbols.inputs:
            out += '\n'.join(f"i{idx} {name}" for name, idx in self.symbols.inputs.items()) + '\n'
        if self.symbols.outputs:
            out += '\n'.join(f"o{idx} {name}" for name, idx in self.symbols.outputs.items()) + '\n'
        if self.symbols.latches:
            out += '\n'.join(f"l{idx} {name}" for name, idx  in self.symbols.latches.items()) + '\n'
            out += 'c\nAutogenerated composition.\n'
        return out


def seq_compose(aag1, aag2):
    # TODO: clean up....this is a mess...
    # TODO: Make sure latch names don't collide
    outputs1 = set(aag1.symbols.outputs.keys())
    inputs2 = set(aag2.symbols.inputs.keys())

    input2_lits = bidict({aag2.inputs[v] & -2: k
                          for k,v in aag2.symbols.inputs.items()})
    output1_lits = bidict({aag1.outputs[v] & -2: k
                           for k,v in aag1.symbols.outputs.items()})
    signed_output = {k: aag1.outputs[v]
                     for k,v in aag1.symbols.outputs.items()}
    
    n = aag1.header.max_var_index
    def update_lit(lit):
        key = lit & -2
        if key == 0:
            return lit
        negated = lit % 2

        # Check if these inputs should be wired together.
        if key in input2_lits:
            sym_name = input2_lits[key]

            if sym_name in aag1.symbols.outputs:
                new_val = aag1.outputs[aag1.symbols.outputs[sym_name]]
                return (new_val & -2) + ((new_val & 1) ^ negated)

        return lit + 2*n

    def update_lits(lits):
        return list(map(update_lit, lits))

    gates3 = aag1.gates + list(map(update_lits, aag2.gates))
    latches3 = aag1.latches + list(map(update_lits, aag2.latches))

    inputs3 = aag1.inputs + update_lits([input2_lits.inv[k]
                                         for k in inputs2 - outputs1])

    outputs3 = update_lits(aag2.outputs) + [signed_output[k]
                                            for k in outputs1 - inputs2]
    
    header1, header2 = aag1.header, aag2.header
    max_var_index = max(fn.flatten(inputs3 + outputs3 + latches3 + gates3)) >> 1
    header3 = Header(
        max_var_index,
        len(inputs3),
        len(latches3),
        len(outputs3),
        len(gates3))
    
    symbols3 = SymbolTable(
        fn.merge(aag1.symbols.inputs,
                 {n: inputs3.index(update_lit(input2_lits.inv[n])) for 
                  n in  inputs2 - outputs1}
        ),
        fn.merge(aag2.symbols.outputs,
                 {n: outputs3.index(signed_output[n]) for 
                  n in outputs1 - inputs2}
        ),
        fn.merge(aag1.symbols.latches, 
                 bidict({k: v + len(aag1.symbols.latches)
                     for k, v in aag2.symbols.latches.items()})),
    )

    # TODO: propogate comments
    return AAG(header3, inputs3, outputs3, latches3, gates3, symbols3, [''])
